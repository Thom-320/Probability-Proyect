---
title: "Análisis de estilo de vida y salud"
author: "[Actualizar con nombres del equipo]"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
```

## 0. Cargar paquetes y datos

```{r libraries}
required_packages <- c(
  "tidyverse", "janitor", "skimr", "gt",
  "GGally", "broom", "gridExtra", "viridis"
)

invisible(lapply(required_packages, function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    stop(paste0("El paquete '", pkg, "' no está instalado. Instálalo antes de compilar el notebook."))
  }
  library(pkg, character.only = TRUE)
}))

theme_set(theme_minimal(base_size = 11))

datos <- readr::read_csv("data/health_lifestyle_classification.csv") |> 
  janitor::clean_names()

# Ajustar tipos de variables categóricas
categoricas <- c(
  "gender", "sleep_quality", "alcohol_consumption", "smoking_level",
  "mental_health_support", "education_level", "job_type", "occupation",
  "diet_type", "exercise_type", "device_usage", "healthcare_access",
  "insurance", "sunlight_exposure", "caffeine_intake", "family_history",
  "pet_owner", "target"
)

datos <- datos |> mutate(across(all_of(categoricas), as.factor))

# Variables ordinales (ajustar el orden según interpretación del equipo)
ord_sleep <- c("Poor", "Fair", "Good", "Excellent")
ord_alcohol <- c("None", "Occasionally", "Regularly")
ord_smoking <- c("Non-smoker", "Light", "Moderate", "Heavy")
ord_healthcare <- c("Poor", "Moderate", "Good", "Excellent")
ord_device <- c("Low", "Moderate", "High")

ordenes <- list(
  sleep_quality = ord_sleep,
  alcohol_consumption = ord_alcohol,
  smoking_level = ord_smoking,
  healthcare_access = ord_healthcare,
  device_usage = ord_device
)

for (var in names(ordenes)) {
  if (var %in% names(datos)) {
    datos[[var]] <- factor(datos[[var]], levels = ordenes[[var]], ordered = TRUE)
  }
}

# Guardar un tibble con metadatos básicos
metadata <- tibble(
  variable = names(datos),
  tipo = sapply(datos, function(x) class(x)[1]),
  descripcion = NA_character_
)
```

## 1. Marco metodológico y objetivo

**Sugerencia:** redactar este apartado en estilo narrativo. Incluya detalles sobre el origen simulado de los datos, descripción general del instrumento de recolección y contexto de aplicación.

```{r marco-metodologico}
tipos <- vapply(datos, function(x) class(x)[1], character(1))
marco_general <- tibble(
  indicador = c(
    "Registros",
    "Variables",
    "Variables cuantitativas",
    "Variables categóricas"
  ),
  valor = c(
    nrow(datos),
    ncol(datos),
    sum(tipos %in% c("numeric", "integer", "double")),
    sum(tipos %in% c("factor", "ordered"))
  )
)

gt::gt(marco_general)
```

*Objetivo del análisis:* `<<Redactar un objetivo claro y medible para el estudio>>`

## 2. Análisis descriptivo de variables categóricas

### 2.1 Análisis univariado

```{r cat-univar}
cat_vars <- metadata |> 
  filter(tipo %in% c("factor", "ordered")) |> 
  pull(variable)

frecuencias_cat <- datos |> 
  select(all_of(cat_vars)) |> 
  mutate(across(everything(), as.character)) |> 
  pivot_longer(everything(), names_to = "variable", values_to = "categoria") |> 
  group_by(variable, categoria) |> 
  summarise(n = n(), .groups = "drop") |> 
  group_by(variable) |> 
  mutate(
    porcentaje = n / sum(n)
  )

frecuencias_cat |> 
  filter(variable %in% cat_vars[1:6]) |> 
  ggplot(aes(x = categoria, y = porcentaje, fill = categoria)) +
  geom_col() +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_viridis_d(option = "C", end = 0.9, guide = "none") +
  facet_wrap(~ variable, scales = "free_x") +
  labs(x = NULL, y = "Proporción", title = "Distribución marginal de variables categóricas (ejemplo)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Tabla resumen para documento (ajustar número de variables a mostrar)
frecuencias_cat |> 
  filter(variable %in% cat_vars[1:3]) |> 
  mutate(porcentaje = scales::percent(porcentaje)) |> 
  arrange(variable, desc(n)) |> 
  gt::gt(groupname_col = "variable")
```

### 2.2 Análisis bivariado entre variables categóricas

```{r cat-bivar}
# Seleccionar pares de interés (ajustar según narrativa)
pares_cat <- tibble(
  variable_x = c("gender", "education_level", "diet_type"),
  variable_y = c("target", "job_type", "exercise_type")
)

coincidencias <- map2(pares_cat$variable_x, pares_cat$variable_y, ~ {
  x_sym <- rlang::sym(.x)
  y_sym <- rlang::sym(.y)
  tabla <- datos |> 
    count(!!x_sym, !!y_sym, name = "n") |> 
    group_by(!!x_sym) |> 
    mutate(prop = n / sum(n)) |> 
    ungroup()
  grafico <- tabla |> 
    ggplot(aes(x = !!y_sym, y = prop, fill = !!y_sym)) +
    geom_col() +
    scale_y_continuous(labels = scales::percent_format()) +
    labs(
      title = paste("Proporción de", .y, "condicionada por", .x),
      x = .y,
      y = "Proporción",
      fill = .y
    ) +
    facet_wrap(vars(!!x_sym)) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  list(
    descripcion = paste(.x, "vs", .y),
    tabla = tabla,
    grafico = grafico
  )
})

# Mostrar gráficos de ejemplo
walk(coincidencias, ~ print(.x$grafico))

# Tabla de frecuencias para el primer par
coincidencias[[1]]$tabla |> 
  gt::gt()
```

## 3. Análisis descriptivo de variables cuantitativas

### 3.1 Análisis univariado

```{r cuant-univar}
cuant_vars <- metadata |> 
  filter(tipo %in% c("numeric", "integer")) |> 
  pull(variable)

skewness <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) < 3 || sd(x) == 0) return(NA_real_)
  mean(((x - mean(x)) / sd(x))^3)
}

kurtosis_excess <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) < 4 || sd(x) == 0) return(NA_real_)
  mean(((x - mean(x)) / sd(x))^4) - 3
}

resumen_cuant <- datos |> 
  select(all_of(cuant_vars)) |> 
  pivot_longer(everything(), names_to = "variable", values_to = "valor") |> 
  group_by(variable) |> 
  summarise(
    media = mean(valor, na.rm = TRUE),
    mediana = median(valor, na.rm = TRUE),
    desviacion = sd(valor, na.rm = TRUE),
    q1 = quantile(valor, 0.25, na.rm = TRUE),
    q3 = quantile(valor, 0.75, na.rm = TRUE),
    minimo = min(valor, na.rm = TRUE),
    maximo = max(valor, na.rm = TRUE),
    asimetria = skewness(valor),
    curtosis = kurtosis_excess(valor),
    faltantes = sum(is.na(valor)),
    .groups = "drop"
  )

resumen_cuant |> 
  mutate(across(where(is.numeric), round, 3)) |> 
  gt::gt()

vars_para_hist <- c("age", "bmi", "sleep_hours", "daily_steps", "stress_level", "mental_health_score")

# Histogramas
if (all(vars_para_hist %in% names(datos))) {
  datos |> 
    select(all_of(vars_para_hist)) |> 
    pivot_longer(everything(), names_to = "variable", values_to = "valor") |> 
    ggplot(aes(x = valor)) +
    geom_histogram(fill = "#2a9d8f", color = "white", bins = 30) +
    facet_wrap(~ variable, scales = "free") +
    labs(title = "Distribuciones univariadas de variables cuantitativas", x = NULL, y = "Frecuencia")

  datos |> 
    select(all_of(vars_para_hist)) |> 
    pivot_longer(everything(), names_to = "variable", values_to = "valor") |> 
    ggplot(aes(x = variable, y = valor, fill = variable)) +
    geom_boxplot(alpha = 0.85) +
    scale_fill_viridis_d(option = "C", guide = "none") +
    labs(x = NULL, y = NULL, title = "Boxplots comparativos") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
```

### 3.2 Análisis bivariado cuantitativo

```{r cuant-bivar}
pares_cuant <- datos |> 
  select(daily_steps, calorie_intake, stress_level, physical_activity, sleep_hours, bmi)

cor_matrix <- round(cor(pares_cuant, use = "pairwise.complete.obs"), 2)

cor_matrix |> 
  as.data.frame() |> 
  rownames_to_column("variable") |> 
  gt::gt()

set.seed(123)
muestra_cuant <- datos |> 
  select(daily_steps, calorie_intake, stress_level, physical_activity, sleep_hours, bmi) |> 
  drop_na() |> 
  slice_sample(n = 2000)

GGally::ggpairs(muestra_cuant)
```

**Sugerencia analítica:** describa si las variables seleccionadas se ajustan a distribuciones conocidas (normal, log-normal, Poisson, etc.) en función de los gráficos, medidas de asimetría y curtosis.

## 4. Relación entre variables categóricas y cuantitativas

```{r cat-cuant}
ejemplos_cat <- c("target", "sleep_quality", "diet_type", "smoking_level")
cuant_vars_interes <- c("bmi", "sleep_hours", "daily_steps", "stress_level")

resumen_cat_cuant <- map_dfr(ejemplos_cat, function(cat_var) {
  cat_sym <- rlang::sym(cat_var)
  datos |> 
    select(!!cat_sym, all_of(cuant_vars_interes)) |> 
    pivot_longer(cols = all_of(cuant_vars_interes), names_to = "variable_cuant", values_to = "valor") |> 
    group_by(grupo = !!cat_sym, variable_cuant) |> 
    summarise(
      n = n(),
      media = mean(valor, na.rm = TRUE),
      mediana = median(valor, na.rm = TRUE),
      sd = sd(valor, na.rm = TRUE),
      q1 = quantile(valor, 0.25, na.rm = TRUE),
      q3 = quantile(valor, 0.75, na.rm = TRUE),
      .groups = "drop"
    ) |> 
    mutate(variable_categorica = cat_var)
})

resumen_cat_cuant |> 
  mutate(across(where(is.numeric), round, 3)) |> 
  gt::gt(groupname_col = "variable_categorica")

pares_cat_cuant <- tribble(
  ~cat, ~cuant,
  "target", "bmi",
  "sleep_quality", "sleep_hours",
  "diet_type", "daily_steps",
  "smoking_level", "stress_level"
)

graficos_cat_cuant <- map2(pares_cat_cuant$cat, pares_cat_cuant$cuant, function(cat_var, cuant_var) {
  cat_sym <- rlang::sym(cat_var)
  cuant_sym <- rlang::sym(cuant_var)
  datos |> 
    ggplot(aes(x = !!cat_sym, y = !!cuant_sym, fill = !!cat_sym)) +
    geom_boxplot(alpha = 0.85, outlier_alpha = 0.25) +
    scale_fill_viridis_d(option = "B", end = 0.9, guide = "none") +
    labs(
      title = paste("Distribución de", cuant_var, "por", cat_var),
      x = cat_var,
      y = cuant_var
    ) +
    theme(axis.text.x = element_text(angle = 35, hjust = 1))
})

walk(graficos_cat_cuant, print)
```

## 5. Pruebas de hipótesis

```{r pruebas-hipotesis}
# 5.1 Prueba para la media: horas de sueño promedio vs. referencia de 7 horas
prueba_media <- t.test(datos$sleep_hours, mu = 7)
resultado_media <- broom::tidy(prueba_media)

resultado_media |> 
  mutate(across(where(is.numeric), round, 4)) |> 
  gt::gt()

# 5.2 Prueba para una proporción: proporción de participantes "healthy" vs. 70%
conteo_target <- datos |> 
  summarise(
    exito = sum(target == "healthy", na.rm = TRUE),
    total = n()
  )

prueba_prop <- prop.test(x = conteo_target$exito, n = conteo_target$total, p = 0.70, alternative = "two.sided")
resultado_prop <- broom::tidy(prueba_prop)

resultado_prop |> 
  mutate(across(where(is.numeric), round, 4)) |> 
  gt::gt()
```

**Nota:** Interprete cada prueba definiendo claramente las hipótesis nula y alternativa, revisando supuestos (normalidad, tamaño muestral, etc.) y contextualizando los hallazgos con la narrativa del informe.

## 6. Anexo: Diccionario de variables

```{r diccionario}
diccionario <- metadata |> 
  mutate(
    tipo_variable = case_when(
      tipo %in% c("numeric", "integer") ~ "Cuantitativa",
      tipo %in% c("factor", "ordered") ~ "Categórica",
      TRUE ~ tipo
    ),
    valores_unicos = map_int(datos[variable], ~ dplyr::n_distinct(.x, na.rm = TRUE))
  ) |> 
  select(variable, tipo_variable, valores_unicos, descripcion)

diccionario |> 
  gt::gt() |> 
  gt::tab_spanner(label = "Completar las descripciones antes de la entrega", columns = everything())
```

```{r faltantes}
# Resumen de valores faltantes para complementar la discusión metodológica
faltantes <- datos |> 
  summarise(across(everything(), ~ sum(is.na(.)))) |> 
  pivot_longer(everything(), names_to = "variable", values_to = "faltantes") |> 
  mutate(pct = faltantes / nrow(datos)) |> 
  arrange(desc(faltantes))

faltantes |> 
  filter(faltantes > 0) |> 
  mutate(pct = scales::percent(pct)) |> 
  slice_head(n = 15) |> 
  gt::gt()
```

> **Recordatorio para el informe:** redacte conclusiones y recomendaciones alineadas con los hallazgos clave. Asegúrese de que las tablas y figuras seleccionadas estén referenciadas en el documento PDF y que incluyan títulos, fuentes y notas interpretativas cuando sea necesario.
